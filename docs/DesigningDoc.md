# 设计文档
## 1. FrontEnd
### A. Lexer
### B. Parser
### C. Static Type-checking (Error Handling)
### D. Intermediate Representation Generation
#### 1. `FrontEnd`内部结构重新梳理
+ `<package> lexer` `(词法分析器)`
+ `<package> parser` `(语法分析器)`
+ `<package> errorChecker` `(错误处理器[静态类型检查])`
+ `<package> nodes` `(抽象语法树[AST]节点)`
+ `<package> IRGenerator` `(中间表示生成器)`
  + `<package> IRTbl` `(中间结构符号表[主要用于常量的处理])`
  + `<package> Quadruple` `(四元式结构)`
  + `<class> IRCodes` `(四元式列表)`
  + `<class> IRGenerator` `(中间表示生成器，起与"后端_Backend"、"抽象语法树节点_nodes"以及"中间结构优化器[IROptimizer]"交互的作用)`
  + `<class> IROptimizer` **(Not implemented yet)**
#### 2. 总体执行流
+ 
## 2. BackEnd
### 2-1. 为中间代码填坑
#### 2-1-1. 全局声明
+ 在设计全局变量声明中间代码时，将声明过程分为“定义”与“初始化”两部分，其中“初始化”由`assign`语句实现，这个过程很不合理，原因有二：
  + 全局本身的声明与初始化本身便是两个密不可分的过程：开头在`.data`字段声明，调用时使用`lw`, 赋值时使用`sw`。
  + 在开始时想要将二者分离实现是因为`InitVal`中可能会出现非常量，但是由于在全局初始化阶段没有任何的重新赋值操作，因此即使非常量的值也是确定的，需要特殊处理。
+ 常量数组也需要存储
  + 对于形如下方代码块中的操作，`offset`为变量的情况仍然需要从内存中提取变量。
    ```
    const int a[2] = {0, 1};
    int b;
    b = a[b];
    ```
#### 2-1-2. 中间码存储
+ `data`段与`text`段需要分开处理，因此需要将全局常/变量与打印字符串声明单独存储
+ `text`段内部函数声明与主体也需要单独存储
  + 需要在`IRContext`中增加上下文`in_func_def`信息，帮助区分哪些`Stmt`在函数内部。

#### 2-1-3. `_3_Assign_Q`

+ 我们希望只有在对非临时变量进行赋值时使用该类语句，即左值不会出现**临时变量**
+ 对于**临时变量**倒寄存器这类操作，在`Exp`内部实现

### 2-2. 机器码生成

#### 2-2-1. `data`字段
+ `const array`
+ `var`
+ `var array`
+ `const str`

分以下四类翻译即可。

#### 2-2-2. `MIPS`布局

#### 2-2-3. 寄存器使用

| Name            | Number | 保留 | 原因                                                         |
| --------------- | ------ | ---- | ------------------------------------------------------------ |
| $zero           | 0      | Y    |                                                              |
| $at             | 1      | Y    | 当`reg-reg-imm`指令的立即数出现越界时，Mars会将其当做`伪指令`识别，并使用`$1`寄存器与`ori`,`lui`指令将其转化成三条指令，不可占用 |
| $v0             | 2      | Y    | 1. 存储函数返回值<br/>2. 中断调用时会使用                    |
| $a0             | 4      | Y    | 中断调用时使用                                               |
| $sp(0x7fffeffc) | 29     | Y    | 栈指针，函数调用与声明内部操作均会使用                       |
| $fp             | 30     | Y    | 存储堆的初始地址(0x10040000)，好像没什么大用                 |
| $ra             | 31     | Y    | 函数调用时跳转指令保存返回指令位置                           |


```java
int[] tmp_regs = {3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 24, 25, 26, 27, 28};
int[] globalregs = {16, 17, 18, 19, 20, 21, 22, 23};
private HashMap<Integer, Boolean> regpool = new HashMap<>();
private HashMap<Integer, Sym> globalreg2sym = new HashMap<>(); //16-23
private HashMap<Integer, Sym> tmpreg2sym = new HashMap<>(); //3 5-15 24-28
```

#### 2-2-4. 注意事项

目标码生成顺序：

1. 全局变量
   + 建立变量-内存符号表
2. 函数声明
   + 为函数打印跳转标签，我们令**函数标签**就是本身**标识符**，方便。
   + 建立临时的函数内部变量-内存映射表，随时清除
   + 查表也很有技巧：
     + 先查局部变量
     + 再查参数
     + 最后查全局变量
3. 主函数
   + 最后一步

#### 2-2-5. 各中间代码的具体转换

#### A. `_1_VarDecl_Q` / `_2_ArrDecl_Q`

##### 主函数中

+ 对于`main`函数，局部变量存储在堆段，由于本课程没有涉及动态空间分配和跨文件调用，所以将堆的地址(0x10040000)作为一个常量在`java`代码中使用，使用时就存入符号表并累加，避免了使用指针来进行存取。
+ 我在实现非全局变量声明时，将**初始化**移入赋值语句中实现，因此局部变量声明没有代码生成，只维护一个符号表。

#### B. `_12_Label_Q`

+ 难点：为函数加标签

#### C. `_3_Assign_Q`

+ 事先明确，需要处理的左值包括：
  + 已声明的各类**数组元素**与**变量**的赋值
  + 未声明的临时变量的赋值



对于一般的函数，局部变量存储在**栈**中，即`$sp`指针指向的地址中。

普通函数的局部变量存储时设计成采用相对于堆的负数的地址，比如`sw $2 -12($sp)`，这样做是为了和实参数进行区分，函数由于要接受传入的实参，因此实参必定是在`$sp`之上，为了不引起递归时的混淆，参数统一在函数内部运行时在`$sp`之上，局部变量则在`$sp`之下。

#### 2-2-4.  函数

稍显棘手的部分来了，下面分步解决两个难点：

##### A.

#### 



#### 函数调用

普通函数的传参采用直接`push`参数到栈指针内的方式，并不断减小，同时将需要的寄存器值和返回地址也存入，在调用完函数之后，再退栈，将寄存器值和返回地址存入相应的寄存器。普通数字变量传参采用直接将值`push`进栈，对于数组变量采用`push`地址进栈，返回值用`$v0`保存，将其赋值给需要的寄存器即可。例子如下

```asm
sw $31 0($sp) #先压入31号返回地址寄存器
li $3 0x0
addi $3 $3 0x1001001c
sw $3 -4($sp) #压入数组参数
li $5 0xc
addi $5 $5 0x10040000
sw $5 -8($sp) #压入数组参数
subi $sp $sp 12 #栈空间压缩
jal funcAA
addi $sp $sp 12 #退栈，栈空间回收
lw $31 0($sp) #恢复31号寄存器值
move $6 $2 #将$v0的值给需要的寄存器
sw $6 0x10040018($0)
lw $3 0x10040018($0)
```

#### 一般的代码翻译

设计了一个工具类`Namespace`，类似`enum`枚举变量，保存数字，寄存器，标签，根据`type`属性区分。方便归一管理和操作。每一个`MipsCode`子类都使用了`Namespace`类作为自己的属性来导出代码。

对于一般的表达式，定义函数`lsym2ns` `rsym2ns` `rsym2ns2`三个函数，目的是将前端的`Sym`类转换成后端的`ns`类，一般是寄存器形式，从而方便进行代码生成，将`sym`转换为`namaspace`之后，就可以很方便的使用`MIPS`指令进行后续操作。具体转换方法是，针对前端标记好的不同形式的变量，比如`% @ t &`等不同的开头符号，确定相应的`Sym`的语义类型。临时变量`t`将其与寄存器建立联系，并返回寄存器。定义的变量则先从内存中`load`出来数据到寄存器中再返回。遇到被分配了寄存器的变量则直接返回相应的寄存器。

对于其他的代码，也是类似，先利用`sym2ns`系列的函数，将前端的每个中间代码中的`Sym`类利用符号表和一定的规则转换为相应的寄存器变量或者数字变量，让后端在输出时可以很好的输出。

#### 后端符号表

后端也复用了前端中间代码生成阶段的符号表，并在前端符号表内加入了地址和一些标记变量易于处理。

具体划分区域使用前端标记好的`Label`进行区分，每次到了新的一层，即检测到`Label`字符串符合某种格式比如`block_func`开头，`block_main`开头，`block_`开头，就进行相应的处理，比如在符号表内创建新的`Block`，或者删除符号表指针。

#### 寄存器分配

此处仅讨论临时寄存器分配，全局寄存器分配见下一部分的图着色介绍。

本次作业我们能够使用的寄存器有`3,5-28`号，其他的均需要使用。其中临时寄存器是`3,5-15,24-28`

```java
int[] tmpregs = {3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 24, 25, 26, 27, 28};
int[] globalregs = {16, 17, 18, 19, 20, 21, 22, 23};
private HashMap<Integer, Boolean> regpool = new HashMap<>();
private HashMap<Integer, Sym> globalreg2sym = new HashMap<>(); //16-23
private HashMap<Integer, Sym> tmpreg2sym = new HashMap<>(); //3 5-15 24-28
```

临时寄存器采用`FIFO`策略，先来先使用，每条语句结束之后会先检查哪些寄存器使用了但是没有与变量关联（即没用），或者与变量关联了但是这个变量之后无用了（即出口处不活跃且这条语句是最后被使用的），将这些无用寄存器先置为空闲。设计了一个`getReg`方法。即如果有空闲的，直接用。没有空闲的，寻找有无没有和某个变量联系的寄存器，有，则使用这个。如果还没有，就直接使用第一个寄存器。

```java
private Namespace getReg() {
    for (int reg : tmpregs) {
        if (!regpool.get(reg) && !tmpreg2sym.containsKey(reg)) {
            regpool.put(reg, true);
            return new Namespace(reg, 0);
        }
    }
    for (int reg : tmpregs) {
        if (!tmpreg2sym.containsKey(reg)) {
            regpool.put(reg, true);
            return new Namespace(reg, 0);
        }
    }
    return new Namespace(tmpregs[0], 0);
}
```

每解析完一个函数，释放所有的临时寄存器和全局寄存器。每开始解析一个函数，设置相应的全局寄存器信息。